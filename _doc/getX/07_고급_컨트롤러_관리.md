# GetX 고급 컨트롤러 관리

## 고급 컨트롤러 등록 방법

### 1. Get.lazyPut() - 지연 등록

```dart
// 컨트롤러를 등록하되, 실제 사용할 때까지 생성하지 않음
Get.lazyPut(() => CounterController());

// 나중에 사용할 때 생성됨
final controller = Get.find<CounterController>();
```

**특징:**

- 메모리 효율적 (필요할 때만 생성)
- 첫 번째 접근 시 생성
- 자동 메모리 관리

### 2. Get.create() - 매번 새로 생성

```dart
// 매번 새로운 인스턴스 생성
Get.create(() => CounterController());

// 매번 다른 인스턴스
final controller1 = Get.find<CounterController>();
final controller2 = Get.find<CounterController>();
// controller1 != controller2
```

### 3. Get.delete() - 컨트롤러 삭제

```dart
// 특정 컨트롤러 삭제
Get.delete<CounterController>();

// 모든 컨트롤러 삭제
Get.deleteAll();
```

## 태그를 사용한 컨트롤러 관리

### 기본 태그 사용

```dart
// 태그로 구분된 컨트롤러 등록
Get.put(CounterController(), tag: 'counter1');
Get.put(CounterController(), tag: 'counter2');

// 태그로 찾기
final controller1 = Get.find<CounterController>(tag: 'counter1');
final controller2 = Get.find<CounterController>(tag: 'counter2');
```

### 동적 태그 사용

```dart
class UserProfileWidget extends StatelessWidget {
  final String userId;

  UserProfileWidget({required this.userId});

  @override
  Widget build(BuildContext context) {
    // userId로 태그 구분
    final controller = Get.put(
      UserController(),
      tag: 'user_$userId'
    );

    return Container(
      child: Text('${controller.name.value}'),
    );
  }
}
```

## 컨트롤러 생명주기 관리

### 생명주기 메서드

```dart
class LifecycleController extends GetxController {
  @override
  void onInit() {
    super.onInit();
    print('컨트롤러 초기화');
    // 초기화 작업
  }

  @override
  void onReady() {
    super.onReady();
    print('컨트롤러 준비 완료');
    // 위젯이 렌더링된 후 실행
  }

  @override
  void onClose() {
    print('컨트롤러 종료');
    // 정리 작업
    super.onClose();
  }
}
```

### 조건부 초기화

```dart
class ConditionalController extends GetxController {
  bool _initialized = false;

  @override
  void onInit() {
    super.onInit();
    if (!_initialized) {
      _initializeData();
      _initialized = true;
    }
  }

  void _initializeData() {
    // 초기화 로직
  }
}
```

## 컨트롤러 의존성 주입

### 단순 의존성

```dart
class UserController extends GetxController {
  final ApiService apiService;

  UserController({required this.apiService});

  // 사용
  Future<void> fetchUsers() async {
    final users = await apiService.getUsers();
    // 처리
  }
}

// 등록
Get.put(ApiService());
Get.put(UserController(apiService: Get.find<ApiService>()));
```

### 복잡한 의존성

```dart
class ComplexController extends GetxController {
  final ApiService apiService;
  final CacheService cacheService;
  final LoggerService loggerService;

  ComplexController({
    required this.apiService,
    required this.cacheService,
    required this.loggerService,
  });

  Future<void> fetchData() async {
    try {
      // 캐시 확인
      final cached = await cacheService.get('data');
      if (cached != null) {
        return cached;
      }

      // API 호출
      final data = await apiService.getData();

      // 캐시 저장
      await cacheService.set('data', data);

      // 로그 기록
      loggerService.log('Data fetched successfully');

    } catch (e) {
      loggerService.error('Failed to fetch data: $e');
      rethrow;
    }
  }
}

// 등록
void setupDependencies() {
  Get.put(ApiService());
  Get.put(CacheService());
  Get.put(LoggerService());

  Get.put(ComplexController(
    apiService: Get.find<ApiService>(),
    cacheService: Get.find<CacheService>(),
    loggerService: Get.find<LoggerService>(),
  ));
}
```

## 컨트롤러 상태 관리 패턴

### 1. 싱글톤 패턴

```dart
class SingletonController extends GetxController {
  static SingletonController? _instance;

  factory SingletonController() {
    _instance ??= SingletonController._internal();
    return _instance!;
  }

  SingletonController._internal();

  final data = <String>[].obs;
}
```

### 2. 팩토리 패턴

```dart
class ControllerFactory {
  static T createController<T extends GetxController>(T Function() factory) {
    return Get.put(factory());
  }

  static T getController<T extends GetxController>() {
    return Get.find<T>();
  }
}

// 사용
final userController = ControllerFactory.createController(() => UserController());
final settingsController = ControllerFactory.getController<SettingsController>();
```

### 3. 레지스트리 패턴

```dart
class ControllerRegistry {
  static final Map<String, GetxController> _controllers = {};

  static void register(String key, GetxController controller) {
    _controllers[key] = controller;
  }

  static T? get<T extends GetxController>(String key) {
    return _controllers[key] as T?;
  }

  static void unregister(String key) {
    _controllers.remove(key);
  }
}
```

## 성능 최적화

### 1. 지연 로딩

```dart
class LazyController extends GetxController {
  final _data = Rxn<List<String>>();

  List<String> get data => _data.value ?? [];

  Future<void> loadData() async {
    if (_data.value == null) {
      _data.value = await _fetchData();
    }
  }

  Future<List<String>> _fetchData() async {
    // 데이터 로딩 로직
    await Future.delayed(Duration(seconds: 2));
    return ['Item 1', 'Item 2', 'Item 3'];
  }
}
```

### 2. 메모리 관리

```dart
class MemoryEfficientController extends GetxController {
  final _cache = <String, dynamic>{};
  final _maxCacheSize = 100;

  void addToCache(String key, dynamic value) {
    if (_cache.length >= _maxCacheSize) {
      // LRU 캐시 정리
      final oldestKey = _cache.keys.first;
      _cache.remove(oldestKey);
    }
    _cache[key] = value;
  }

  @override
  void onClose() {
    _cache.clear();
    super.onClose();
  }
}
```

### 3. 상태 분리

```dart
// UI 상태만 관리하는 컨트롤러
class UIStateController extends GetxController {
  final isLoading = false.obs;
  final errorMessage = ''.obs;
  final currentTab = 0.obs;
}

// 비즈니스 로직만 관리하는 컨트롤러
class BusinessLogicController extends GetxController {
  final data = <String>[].obs;

  Future<void> fetchData() async {
    // 비즈니스 로직
  }
}

// 사용
class MyPage extends StatelessWidget {
  final uiController = Get.put(UIStateController());
  final businessController = Get.put(BusinessLogicController());

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Obx(() {
        if (uiController.isLoading.value) {
          return CircularProgressIndicator();
        }
        return ListView.builder(
          itemCount: businessController.data.length,
          itemBuilder: (context, index) {
            return ListTile(
              title: Text(businessController.data[index]),
            );
          },
        );
      }),
    );
  }
}
```

## 다음 단계

- [08*성능*최적화.md](08_성능_최적화.md) - GetX 성능 최적화
- [09*실전*패턴.md](09_실전_패턴.md) - 실전에서 사용하는 패턴들
- [10*디버깅*가이드.md](10_디버깅_가이드.md) - GetX 디버깅 방법
