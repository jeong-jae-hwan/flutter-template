# GetX 성능 최적화

## 성능 최적화 개요

GetX는 이미 높은 성능을 제공하지만, 더 나은 성능을 위해 최적화할 수 있는 방법들이 있습니다.

## 1. 불필요한 리빌드 방지

### ✅ 좋은 예: 특정 변수만 관찰

```dart
class OptimizedController extends GetxController {
  final name = '홍길동'.obs;
  final age = 25.obs;
  final email = 'hong@example.com'.obs;
  final address = '서울시 강남구'.obs;
}

class OptimizedWidget extends StatelessWidget {
  final controller = Get.put(OptimizedController());

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        // 이름만 변경될 때만 리빌드
        Obx(() => Text('이름: ${controller.name.value}')),

        // 나이만 변경될 때만 리빌드
        Obx(() => Text('나이: ${controller.age.value}')),

        // 이메일만 변경될 때만 리빌드
        Obx(() => Text('이메일: ${controller.email.value}')),

        // 주소만 변경될 때만 리빌드
        Obx(() => Text('주소: ${controller.address.value}')),
      ],
    );
  }
}
```

### ❌ 나쁜 예: 전체 위젯 리빌드

```dart
class UnoptimizedWidget extends StatelessWidget {
  final controller = Get.put(OptimizedController());

  @override
  Widget build(BuildContext context) {
    return Obx(() => Column(
      children: [
        Text('이름: ${controller.name.value}'),
        Text('나이: ${controller.age.value}'),
        Text('이메일: ${controller.email.value}'),
        Text('주소: ${controller.address.value}'),
        // 다른 많은 위젯들...
      ],
    ));
  }
}
```

## 2. 메모리 관리 최적화

### 컨트롤러 자동 삭제

```dart
// 위젯이 dispose될 때 자동으로 컨트롤러도 삭제
class AutoCleanupWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final controller = Get.put(TempController()); // 자동 삭제
    return Container();
  }
}
```

### 수동 메모리 정리

```dart
class MemoryEfficientController extends GetxController {
  final _largeData = <String>[].obs;
  final _cache = <String, dynamic>{};

  @override
  void onClose() {
    // 큰 데이터 정리
    _largeData.clear();
    _cache.clear();

    // 리스너 해제
    // 타이머 정리
    // 스트림 구독 해제

    super.onClose();
  }
}
```

### 지연 로딩 사용

```dart
// 필요할 때만 컨트롤러 생성
class LazyLoadingWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // 실제 사용할 때까지 생성하지 않음
    Get.lazyPut(() => HeavyController());

    return ElevatedButton(
      onPressed: () {
        // 버튼 클릭 시에만 컨트롤러 생성
        final controller = Get.find<HeavyController>();
        controller.loadData();
      },
      child: Text('데이터 로드'),
    );
  }
}
```

## 3. 상태 분리 최적화

### UI 상태와 비즈니스 로직 분리

```dart
// UI 상태만 관리
class UIStateController extends GetxController {
  final isLoading = false.obs;
  final errorMessage = ''.obs;
  final currentTab = 0.obs;
  final isExpanded = false.obs;
}

// 비즈니스 로직만 관리
class BusinessController extends GetxController {
  final data = <String>[].obs;
  final filteredData = <String>[].obs;

  void loadData() async {
    // 비즈니스 로직
  }

  void filterData(String query) {
    // 필터링 로직
  }
}

// 사용
class OptimizedPage extends StatelessWidget {
  final uiController = Get.put(UIStateController());
  final businessController = Get.put(BusinessController());

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Column(
        children: [
          // UI 상태만 관찰
          Obx(() => uiController.isLoading.value
            ? CircularProgressIndicator()
            : Container()
          ),

          // 비즈니스 데이터만 관찰
          Obx(() => ListView.builder(
            itemCount: businessController.filteredData.length,
            itemBuilder: (context, index) {
              return ListTile(
                title: Text(businessController.filteredData[index]),
              );
            },
          )),
        ],
      ),
    );
  }
}
```

## 4. 리스트 최적화

### 리스트 아이템 최적화

```dart
class OptimizedListController extends GetxController {
  final items = <ListItem>[].obs;

  void addItem(String title) {
    items.add(ListItem(
      id: DateTime.now().millisecondsSinceEpoch,
      title: title,
    ));
  }

  void removeItem(int id) {
    items.removeWhere((item) => item.id == id);
  }
}

class ListItem {
  final int id;
  final String title;

  ListItem({required this.id, required this.title});
}

class OptimizedListView extends StatelessWidget {
  final controller = Get.put(OptimizedListController());

  @override
  Widget build(BuildContext context) {
    return Obx(() => ListView.builder(
      itemCount: controller.items.length,
      itemBuilder: (context, index) {
        final item = controller.items[index];
        return ListTile(
          key: ValueKey(item.id), // 고유 키 사용
          title: Text(item.title),
          trailing: IconButton(
            icon: Icon(Icons.delete),
            onPressed: () => controller.removeItem(item.id),
          ),
        );
      },
    ));
  }
}
```

## 5. 네트워크 요청 최적화

### 캐싱 구현

```dart
class CachedApiController extends GetxController {
  final _cache = <String, dynamic>{};
  final data = <String>[].obs;
  final isLoading = false.obs;

  Future<void> fetchData() async {
    const cacheKey = 'api_data';

    // 캐시 확인
    if (_cache.containsKey(cacheKey)) {
      data.value = _cache[cacheKey];
      return;
    }

    isLoading.value = true;

    try {
      // API 호출
      final response = await apiService.getData();
      data.value = response;

      // 캐시 저장
      _cache[cacheKey] = response;
    } finally {
      isLoading.value = false;
    }
  }

  void clearCache() {
    _cache.clear();
  }
}
```

### 디바운싱 구현

```dart
class DebouncedSearchController extends GetxController {
  final searchQuery = ''.obs;
  final searchResults = <String>[].obs;
  Timer? _debounceTimer;

  void onSearchChanged(String query) {
    searchQuery.value = query;

    // 이전 타이머 취소
    _debounceTimer?.cancel();

    // 새로운 타이머 시작
    _debounceTimer = Timer(Duration(milliseconds: 500), () {
      performSearch(query);
    });
  }

  Future<void> performSearch(String query) async {
    if (query.isEmpty) {
      searchResults.clear();
      return;
    }

    // 검색 로직
    final results = await searchService.search(query);
    searchResults.value = results;
  }

  @override
  void onClose() {
    _debounceTimer?.cancel();
    super.onClose();
  }
}
```

## 6. 이미지 최적화

### 이미지 캐싱

```dart
class ImageController extends GetxController {
  final _imageCache = <String, Uint8List>{};
  final images = <String>[].obs;

  Future<Uint8List?> getImage(String url) async {
    // 캐시 확인
    if (_imageCache.containsKey(url)) {
      return _imageCache[url];
    }

    try {
      // 이미지 다운로드
      final response = await http.get(Uri.parse(url));
      final imageBytes = response.bodyBytes;

      // 캐시 저장
      _imageCache[url] = imageBytes;

      return imageBytes;
    } catch (e) {
      return null;
    }
  }

  void clearImageCache() {
    _imageCache.clear();
  }
}
```

## 7. 성능 모니터링

### 성능 측정

```dart
class PerformanceController extends GetxController {
  final executionTimes = <String, int>{};

  void measureExecution(String operation, Function() callback) {
    final stopwatch = Stopwatch()..start();

    callback();

    stopwatch.stop();
    executionTimes[operation] = stopwatch.elapsedMilliseconds;

    print('$operation 실행 시간: ${stopwatch.elapsedMilliseconds}ms');
  }

  void logPerformance() {
    executionTimes.forEach((operation, time) {
      print('$operation: ${time}ms');
    });
  }
}
```

## 8. 메모리 누수 방지

### 리스너 정리

```dart
class SafeController extends GetxController {
  StreamSubscription? _subscription;
  Timer? _timer;

  @override
  void onInit() {
    super.onInit();

    // 스트림 구독
    _subscription = someStream.listen((data) {
      // 데이터 처리
    });

    // 타이머 설정
    _timer = Timer.periodic(Duration(seconds: 1), (timer) {
      // 주기적 작업
    });
  }

  @override
  void onClose() {
    // 구독 해제
    _subscription?.cancel();

    // 타이머 정리
    _timer?.cancel();

    super.onClose();
  }
}
```

## 성능 최적화 체크리스트

### ✅ 최적화 완료 항목

- [ ] 불필요한 Obx() 사용 방지
- [ ] 리스트에 고유 키 사용
- [ ] 큰 데이터는 지연 로딩 사용
- [ ] 이미지 캐싱 구현
- [ ] 네트워크 요청 디바운싱
- [ ] 컨트롤러 생명주기 관리
- [ ] 메모리 누수 방지
- [ ] 상태 분리 구현

### 📊 성능 측정

```dart
// 성능 측정 유틸리티
class PerformanceUtils {
  static void measure(String operation, Function() callback) {
    final stopwatch = Stopwatch()..start();
    callback();
    stopwatch.stop();
    print('$operation: ${stopwatch.elapsedMilliseconds}ms');
  }

  static void measureAsync(String operation, Future<void> Function() callback) async {
    final stopwatch = Stopwatch()..start();
    await callback();
    stopwatch.stop();
    print('$operation: ${stopwatch.elapsedMilliseconds}ms');
  }
}

// 사용 예시
PerformanceUtils.measure('리스트 렌더링', () {
  // 리스트 렌더링 로직
});

PerformanceUtils.measureAsync('API 호출', () async {
  await apiService.getData();
});
```

## 다음 단계

- [09*실전*패턴.md](09_실전_패턴.md) - 실전에서 사용하는 패턴들
- [10*디버깅*가이드.md](10_디버깅_가이드.md) - GetX 디버깅 방법
- [11*고급*기능.md](11_고급_기능.md) - GetX 고급 기능들
